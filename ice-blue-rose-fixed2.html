<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ice Blue Rose (3D, Wind) · Fixed v2</title>
  <style>
    html,body{height:100%;margin:0;background:#050812;overflow:hidden}
    #c{display:block;width:100%;height:100%}
    .hud{
      position:fixed;left:12px;bottom:12px;right:12px;
      display:flex;gap:10px;align-items:center;flex-wrap:wrap;
      color:#cfe9ff;font:12px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"PingFang SC","Hiragino Sans GB","Microsoft YaHei",Arial;
      opacity:.85;pointer-events:none;text-shadow:0 2px 10px rgba(0,0,0,.6)
    }
    .badge{padding:6px 10px;border:1px solid rgba(120,200,255,.22);border-radius:999px;background:rgba(10,20,40,.35);backdrop-filter:blur(10px)}
  </style>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud">
  <div class="badge">Ice Blue Rose · Three.js · Wind sway（修复 v2）</div>
  <div class="badge">鼠标拖拽旋转 / 滚轮缩放</div>
</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  const canvas = document.getElementById('c');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:'high-performance' });
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.1;

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x050812, 0.065);

  const camera = new THREE.PerspectiveCamera(45, 1, 0.05, 100);
  camera.position.set(0.6, 0.9, 2.25);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.06;
  controls.target.set(0, 0.55, 0);
  controls.minDistance = 1.2;
  controls.maxDistance = 4.0;
  controls.maxPolarAngle = Math.PI * 0.49;

  // Background
  {
    const g = new THREE.SphereGeometry(30, 32, 16);
    const m = new THREE.MeshBasicMaterial({ color: 0x050812, side: THREE.BackSide });
    scene.add(new THREE.Mesh(g, m));

    const starGeo = new THREE.BufferGeometry();
    const starCount = 900;
    const pos = new Float32Array(starCount * 3);
    for (let i=0;i<starCount;i++){
      const r = 10 + Math.random()*16;
      const theta = Math.random()*Math.PI*2;
      const phi = Math.acos(2*Math.random()-1);
      pos[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
      pos[i*3+1] = r*Math.cos(phi);
      pos[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    const starMat = new THREE.PointsMaterial({ color:0xaedcff, size:0.02, sizeAttenuation:true, transparent:true, opacity:0.35 });
    scene.add(new THREE.Points(starGeo, starMat));
  }

  // Lights (FIX: don't Object.assign into .position)
  {
    const key = new THREE.DirectionalLight(0xbfe9ff, 2.2);
    key.position.set(2.2, 3.0, 1.5);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0x6bd6ff, 1.4);
    rim.position.set(-2.5, 1.5, -2.2);
    scene.add(rim);

    const fill = new THREE.HemisphereLight(0x9adfff, 0x0b1226, 0.9);
    scene.add(fill);
  }

  const glowPoint = new THREE.PointLight(0x7bd7ff, 1.8, 12, 2.2);
  glowPoint.position.set(0, 0.9, 0.5);
  scene.add(glowPoint);

  // Ground
  {
    const g = new THREE.CircleGeometry(2.2, 64);
    const m = new THREE.MeshStandardMaterial({ color: 0x071024, metalness: 0.1, roughness: 0.75 });
    const ground = new THREE.Mesh(g, m);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = 0;
    scene.add(ground);

    const haloG = new THREE.RingGeometry(0.35, 1.7, 96);
    const haloM = new THREE.MeshBasicMaterial({ color: 0x59cfff, transparent:true, opacity:0.10, side: THREE.DoubleSide });
    const halo = new THREE.Mesh(haloG, haloM);
    halo.rotation.x = -Math.PI/2;
    halo.position.y = 0.002;
    scene.add(halo);
  }

  // Materials
  const icePetalMat = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color('#8fe7ff'),
    roughness: 0.18,
    metalness: 0.02,
    transmission: 0.72,
    thickness: 0.9,
    ior: 1.33,
    clearcoat: 1.0,
    clearcoatRoughness: 0.08,
    specularIntensity: 1.0,
    specularColor: new THREE.Color('#e9fbff'),
    sheen: 0.4,
    sheenColor: new THREE.Color('#bff6ff'),
    sheenRoughness: 0.35
  });

  const frostMat = new THREE.MeshStandardMaterial({
    color: new THREE.Color('#d7fbff'),
    metalness: 0.0,
    roughness: 0.55,
    transparent:true,
    opacity:0.20
  });

  const stemMat = new THREE.MeshStandardMaterial({ color: new THREE.Color('#0c7aa0'), metalness: 0.0, roughness: 0.55 });

  // Rose group
  const rose = new THREE.Group();
  rose.position.y = 0.02;
  scene.add(rose);

  // Stem + leaves
  {
    const curve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(0, 0.02, 0),
      new THREE.Vector3(-0.03, 0.25, 0.02),
      new THREE.Vector3(0.02, 0.55, -0.02),
      new THREE.Vector3(0, 0.78, 0)
    ]);
    const tubeGeo = new THREE.TubeGeometry(curve, 120, 0.03, 12, false);
    const tube = new THREE.Mesh(tubeGeo, stemMat);
    rose.add(tube);

    const leafShape = new THREE.Shape();
    leafShape.moveTo(0,0);
    leafShape.bezierCurveTo(0.18, 0.10, 0.30, 0.28, 0.16, 0.46);
    leafShape.bezierCurveTo(0.02, 0.64,-0.10, 0.50,-0.16, 0.38);
    leafShape.bezierCurveTo(-0.22, 0.26,-0.12, 0.10, 0, 0);
    const leafGeo = new THREE.ExtrudeGeometry(leafShape, { depth: 0.01, bevelEnabled:false, steps:1 });
    leafGeo.center();
    const leafMat = new THREE.MeshStandardMaterial({ color:0x0ea8c8, roughness:0.6, metalness:0.05 });

    const leaf1 = new THREE.Mesh(leafGeo, leafMat);
    leaf1.position.set(0.08, 0.38, 0.02);
    leaf1.rotation.set(0.2, 0.6, 0.1);
    leaf1.scale.set(0.55, 0.55, 0.55);
    rose.add(leaf1);

    const leaf2 = leaf1.clone();
    leaf2.position.set(-0.10, 0.50, -0.01);
    leaf2.rotation.set(-0.25, -0.7, -0.1);
    leaf2.scale.set(0.62, 0.62, 0.62);
    rose.add(leaf2);
  }

  function makePetalGeometry(width=0.28, height=0.48, curl=0.75){
    const geo = new THREE.PlaneGeometry(width, height, 18, 26);
    const pos = geo.attributes.position;
    for (let i=0;i<pos.count;i++){
      const x = pos.getX(i);
      const y = pos.getY(i);
      const t = (y/height) + 0.5;
      const bend = Math.pow(t, 1.7) * curl;
      const z = Math.sin((x/width)*Math.PI) * bend * 0.16 + bend * 0.08;
      const cup = (1 - Math.abs(x)/(width*0.55));
      const z2 = Math.max(0, cup) * (0.06 * Math.pow(t, 1.2));
      pos.setZ(i, z + z2);
    }
    geo.computeVertexNormals();
    return geo;
  }

  const petals = [];
  const bloom = new THREE.Group();
  bloom.position.set(0, 0.82, 0);
  rose.add(bloom);

  const layers = [
    { n: 10, r: 0.08, y: 0.00, s: 0.65, tilt: 0.65, curl: 0.95 },
    { n: 12, r: 0.12, y: 0.02, s: 0.80, tilt: 0.52, curl: 0.85 },
    { n: 14, r: 0.16, y: 0.03, s: 0.95, tilt: 0.42, curl: 0.78 },
    { n: 16, r: 0.20, y: 0.04, s: 1.12, tilt: 0.34, curl: 0.70 }
  ];

  for (let li=0; li<layers.length; li++){
    const L = layers[li];
    const g = makePetalGeometry(0.26*L.s, 0.44*L.s, L.curl);
    for (let i=0;i<L.n;i++){
      const ang = (i/L.n) * Math.PI * 2 + (li*0.18);
      const petalMesh = new THREE.Mesh(g, icePetalMat);
      petalMesh.rotation.y = ang + Math.PI/2;
      petalMesh.rotation.x = -L.tilt + (Math.random()-0.5)*0.06;
      petalMesh.rotation.z = (Math.sin(ang*2.3 + li)*0.10) + (Math.random()-0.5)*0.08;

      const frost = new THREE.Mesh(g, frostMat);
      frost.scale.set(1.01, 1.01, 1.01);
      petalMesh.add(frost);

      const pivot = new THREE.Group();
      pivot.position.set(Math.cos(ang)*L.r, L.y, Math.sin(ang)*L.r);
      petalMesh.position.set(0, 0.18*L.s, 0);
      pivot.add(petalMesh);
      bloom.add(pivot);

      petals.push({ pivot, phase: Math.random()*Math.PI*2, strength: 0.6 + Math.random()*0.6, layer: li });
    }
  }

  // Crystal core
  {
    const coreGeo = new THREE.IcosahedronGeometry(0.06, 3);
    const coreMat = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color('#bff6ff'),
      transmission: 0.85,
      thickness: 1.2,
      roughness: 0.08,
      metalness: 0.0,
      ior: 1.36,
      clearcoat: 1,
      clearcoatRoughness: 0.05,
      emissive: new THREE.Color('#1a7aa0'),
      emissiveIntensity: 0.18
    });
    const core = new THREE.Mesh(coreGeo, coreMat);
    core.position.y = 0.05;
    bloom.add(core);
  }

  // Particles
  const particles = [];
  {
    const pGeo = new THREE.SphereGeometry(0.007, 10, 10);
    const pMat = new THREE.MeshPhysicalMaterial({
      color: new THREE.Color('#d8fbff'),
      transmission: 0.9,
      thickness: 0.4,
      roughness: 0.05,
      ior: 1.33,
      emissive: new THREE.Color('#1f8db4'),
      emissiveIntensity: 0.22
    });
    for (let i=0;i<70;i++){
      const m = new THREE.Mesh(pGeo, pMat);
      const r = 0.15 + Math.random()*0.65;
      const a = Math.random()*Math.PI*2;
      const y = 0.35 + Math.random()*0.85;
      m.position.set(Math.cos(a)*r, y, Math.sin(a)*r);
      m.userData = { a, r, y, s: 0.4 + Math.random()*0.9, p: Math.random()*Math.PI*2 };
      scene.add(m);
      particles.push(m);
    }
  }

  function wind(t){
    const g1 = Math.sin(t*0.9) * 0.55 + Math.sin(t*2.1 + 1.7)*0.25;
    const g2 = Math.cos(t*1.3 + 0.6) * 0.45 + Math.sin(t*3.3 + 0.2)*0.18;
    const gust = (Math.sin(t*0.25 + 0.8)*0.5 + 0.5);
    return { x: g1*gust, z: g2*gust, gust };
  }

  function resize(){
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    const need = (canvas.width !== Math.floor(w*renderer.getPixelRatio())) || (canvas.height !== Math.floor(h*renderer.getPixelRatio()));
    if (need){
      renderer.setSize(w, h, false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
  }

  const clock = new THREE.Clock();
  function tick(){
    requestAnimationFrame(tick);
    resize();
    const t = clock.getElapsedTime();
    controls.update();

    const w = wind(t);
    const swayX = w.z * 0.09;
    const swayZ = w.x * 0.09;
    rose.rotation.x = THREE.MathUtils.lerp(rose.rotation.x, swayX, 0.06);
    rose.rotation.z = THREE.MathUtils.lerp(rose.rotation.z, swayZ, 0.06);

    for (const p of petals){
      const layerFactor = 0.5 + p.layer*0.22;
      const flutter = Math.sin(t*3.4 + p.phase) * 0.015 * p.strength;
      const wave = Math.sin(t*1.3 + p.phase*1.7) * 0.022 * p.strength;
      p.pivot.rotation.x = - (0.35 + p.layer*0.07) + wave*layerFactor + flutter;
      p.pivot.rotation.y = (w.x * 0.06 * layerFactor) + Math.sin(t*0.7 + p.phase)*0.01;
      p.pivot.rotation.z = (w.z * 0.05 * layerFactor) + Math.cos(t*0.8 + p.phase)*0.012;
    }

    glowPoint.intensity = 1.5 + Math.sin(t*2.0)*0.25 + w.gust*0.35;

    for (const m of particles){
      const u = m.userData;
      const a = u.a + t*0.25*u.s;
      const r = u.r + Math.sin(t*0.9 + u.p)*0.03;
      m.position.x = Math.cos(a) * r + w.x*0.03;
      m.position.z = Math.sin(a) * r + w.z*0.03;
      m.position.y = u.y + Math.sin(t*1.3 + u.p)*0.03;
      m.scale.setScalar(0.8 + Math.sin(t*2.4 + u.p)*0.2);
    }

    renderer.render(scene, camera);
  }
  tick();

  window.addEventListener('webglcontextlost', (e)=>{
    e.preventDefault();
    alert('WebGL 上下文丢失：请刷新页面或换个浏览器/显卡设置。');
  }, false);
</script>
</body>
</html>
